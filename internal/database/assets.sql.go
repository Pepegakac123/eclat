// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assets.sql

package database

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const claimAssetsForPath = `-- name: ClaimAssetsForPath :exec
UPDATE assets
SET scan_folder_id = ?
WHERE file_path LIKE ? || '%'
AND scan_folder_id != ?
`

type ClaimAssetsForPathParams struct {
	ScanFolderID   sql.NullInt64  `json:"scanFolderId"`
	Column2        sql.NullString `json:"column2"`
	ScanFolderID_2 sql.NullInt64  `json:"scanFolderId2"`
}

func (q *Queries) ClaimAssetsForPath(ctx context.Context, arg ClaimAssetsForPathParams) error {
	_, err := q.exec(ctx, q.claimAssetsForPathStmt, claimAssetsForPath, arg.ScanFolderID, arg.Column2, arg.ScanFolderID_2)
	return err
}

const createAsset = `-- name: CreateAsset :one
INSERT INTO assets (
    scan_folder_id, file_name, file_path, file_type, file_size,
    thumbnail_path, file_hash,
    image_width, image_height, dominant_color, bit_depth, has_alpha_channel,
    last_modified, last_scanned, group_id
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, scan_folder_id, group_id, file_name, file_path, file_type, file_size, thumbnail_path, rating, description, is_favorite, image_width, image_height, dominant_color, bit_depth, has_alpha_channel, date_added, last_scanned, last_modified, file_hash, is_deleted, deleted_at, is_hidden
`

type CreateAssetParams struct {
	ScanFolderID    sql.NullInt64  `json:"scanFolderId"`
	FileName        string         `json:"fileName"`
	FilePath        string         `json:"filePath"`
	FileType        string         `json:"fileType"`
	FileSize        int64          `json:"fileSize"`
	ThumbnailPath   string         `json:"thumbnailPath"`
	FileHash        sql.NullString `json:"fileHash"`
	ImageWidth      sql.NullInt64  `json:"imageWidth"`
	ImageHeight     sql.NullInt64  `json:"imageHeight"`
	DominantColor   sql.NullString `json:"dominantColor"`
	BitDepth        sql.NullInt64  `json:"bitDepth"`
	HasAlphaChannel sql.NullBool   `json:"hasAlphaChannel"`
	LastModified    time.Time      `json:"lastModified"`
	LastScanned     time.Time      `json:"lastScanned"`
	GroupID         string         `json:"groupId"`
}

func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) (Asset, error) {
	row := q.queryRow(ctx, q.createAssetStmt, createAsset,
		arg.ScanFolderID,
		arg.FileName,
		arg.FilePath,
		arg.FileType,
		arg.FileSize,
		arg.ThumbnailPath,
		arg.FileHash,
		arg.ImageWidth,
		arg.ImageHeight,
		arg.DominantColor,
		arg.BitDepth,
		arg.HasAlphaChannel,
		arg.LastModified,
		arg.LastScanned,
		arg.GroupID,
	)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.ScanFolderID,
		&i.GroupID,
		&i.FileName,
		&i.FilePath,
		&i.FileType,
		&i.FileSize,
		&i.ThumbnailPath,
		&i.Rating,
		&i.Description,
		&i.IsFavorite,
		&i.ImageWidth,
		&i.ImageHeight,
		&i.DominantColor,
		&i.BitDepth,
		&i.HasAlphaChannel,
		&i.DateAdded,
		&i.LastScanned,
		&i.LastModified,
		&i.FileHash,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.IsHidden,
	)
	return i, err
}

const deleteAssetByFolder = `-- name: DeleteAssetByFolder :exec
DELETE FROM assets WHERE scan_folder_id = ?
`

func (q *Queries) DeleteAssetByFolder(ctx context.Context, scanFolderID sql.NullInt64) error {
	_, err := q.exec(ctx, q.deleteAssetByFolderStmt, deleteAssetByFolder, scanFolderID)
	return err
}

const deleteAssetPermanent = `-- name: DeleteAssetPermanent :exec
DELETE FROM assets WHERE id = ?
`

func (q *Queries) DeleteAssetPermanent(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteAssetPermanentStmt, deleteAssetPermanent, id)
	return err
}

const findPotentialSiblings = `-- name: FindPotentialSiblings :many
SELECT id, group_id, file_name
FROM assets
WHERE scan_folder_id = ?
  AND file_name LIKE ?
  AND id != ?
LIMIT ?
`

type FindPotentialSiblingsParams struct {
	ScanFolderID sql.NullInt64 `json:"scanFolderId"`
	FileName     string        `json:"fileName"`
	ID           int64         `json:"id"`
	Limit        int64         `json:"limit"`
}

type FindPotentialSiblingsRow struct {
	ID       int64  `json:"id"`
	GroupID  string `json:"groupId"`
	FileName string `json:"fileName"`
}

func (q *Queries) FindPotentialSiblings(ctx context.Context, arg FindPotentialSiblingsParams) ([]FindPotentialSiblingsRow, error) {
	rows, err := q.query(ctx, q.findPotentialSiblingsStmt, findPotentialSiblings,
		arg.ScanFolderID,
		arg.FileName,
		arg.ID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindPotentialSiblingsRow
	for rows.Next() {
		var i FindPotentialSiblingsRow
		if err := rows.Scan(&i.ID, &i.GroupID, &i.FileName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllColors = `-- name: GetAllColors :many
SELECT DISTINCT dominant_color
FROM assets a
JOIN scan_folders f ON a.scan_folder_id = f.id
WHERE a.is_deleted = 0
  AND f.is_deleted = 0
  AND f.is_active = 1
  AND is_hidden = 0
  AND dominant_color IS NOT NULL AND dominant_color != ''
`

func (q *Queries) GetAllColors(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.query(ctx, q.getAllColorsStmt, getAllColors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var dominant_color sql.NullString
		if err := rows.Scan(&dominant_color); err != nil {
			return nil, err
		}
		items = append(items, dominant_color)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssetByHash = `-- name: GetAssetByHash :one
SELECT id, scan_folder_id, group_id, file_name, file_path, file_type, file_size, thumbnail_path, rating, description, is_favorite, image_width, image_height, dominant_color, bit_depth, has_alpha_channel, date_added, last_scanned, last_modified, file_hash, is_deleted, deleted_at, is_hidden FROM assets
WHERE file_hash = ? AND file_hash IS NOT NULL
LIMIT 1
`

func (q *Queries) GetAssetByHash(ctx context.Context, fileHash sql.NullString) (Asset, error) {
	row := q.queryRow(ctx, q.getAssetByHashStmt, getAssetByHash, fileHash)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.ScanFolderID,
		&i.GroupID,
		&i.FileName,
		&i.FilePath,
		&i.FileType,
		&i.FileSize,
		&i.ThumbnailPath,
		&i.Rating,
		&i.Description,
		&i.IsFavorite,
		&i.ImageWidth,
		&i.ImageHeight,
		&i.DominantColor,
		&i.BitDepth,
		&i.HasAlphaChannel,
		&i.DateAdded,
		&i.LastScanned,
		&i.LastModified,
		&i.FileHash,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.IsHidden,
	)
	return i, err
}

const getAssetById = `-- name: GetAssetById :one
SELECT id, scan_folder_id, group_id, file_name, file_path, file_type, file_size, thumbnail_path, rating, description, is_favorite, image_width, image_height, dominant_color, bit_depth, has_alpha_channel, date_added, last_scanned, last_modified, file_hash, is_deleted, deleted_at, is_hidden FROM assets
WHERE id = ? LIMIT 1
`

func (q *Queries) GetAssetById(ctx context.Context, id int64) (Asset, error) {
	row := q.queryRow(ctx, q.getAssetByIdStmt, getAssetById, id)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.ScanFolderID,
		&i.GroupID,
		&i.FileName,
		&i.FilePath,
		&i.FileType,
		&i.FileSize,
		&i.ThumbnailPath,
		&i.Rating,
		&i.Description,
		&i.IsFavorite,
		&i.ImageWidth,
		&i.ImageHeight,
		&i.DominantColor,
		&i.BitDepth,
		&i.HasAlphaChannel,
		&i.DateAdded,
		&i.LastScanned,
		&i.LastModified,
		&i.FileHash,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.IsHidden,
	)
	return i, err
}

const getAssetByPath = `-- name: GetAssetByPath :one
SELECT id, scan_folder_id, group_id, file_name, file_path, file_type, file_size, thumbnail_path, rating, description, is_favorite, image_width, image_height, dominant_color, bit_depth, has_alpha_channel, date_added, last_scanned, last_modified, file_hash, is_deleted, deleted_at, is_hidden FROM assets
WHERE file_path = ? LIMIT 1
`

func (q *Queries) GetAssetByPath(ctx context.Context, filePath string) (Asset, error) {
	row := q.queryRow(ctx, q.getAssetByPathStmt, getAssetByPath, filePath)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.ScanFolderID,
		&i.GroupID,
		&i.FileName,
		&i.FilePath,
		&i.FileType,
		&i.FileSize,
		&i.ThumbnailPath,
		&i.Rating,
		&i.Description,
		&i.IsFavorite,
		&i.ImageWidth,
		&i.ImageHeight,
		&i.DominantColor,
		&i.BitDepth,
		&i.HasAlphaChannel,
		&i.DateAdded,
		&i.LastScanned,
		&i.LastModified,
		&i.FileHash,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.IsHidden,
	)
	return i, err
}

const getAssetsByGroupID = `-- name: GetAssetsByGroupID :many
SELECT id, file_name, file_path
FROM assets
WHERE group_id = ? AND is_deleted = 0
`

type GetAssetsByGroupIDRow struct {
	ID       int64  `json:"id"`
	FileName string `json:"fileName"`
	FilePath string `json:"filePath"`
}

func (q *Queries) GetAssetsByGroupID(ctx context.Context, groupID string) ([]GetAssetsByGroupIDRow, error) {
	rows, err := q.query(ctx, q.getAssetsByGroupIDStmt, getAssetsByGroupID, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssetsByGroupIDRow
	for rows.Next() {
		var i GetAssetsByGroupIDRow
		if err := rows.Scan(&i.ID, &i.FileName, &i.FilePath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLibraryStats = `-- name: GetLibraryStats :one
SELECT
    COUNT(*) as total_count,
    CAST(COALESCE(SUM(file_size), 0) AS INTEGER) as total_size,
    MAX(a.last_scanned) as last_scan
FROM assets a
JOIN scan_folders f ON a.scan_folder_id = f.id
WHERE a.is_deleted = 0 AND f.is_deleted = 0 AND f.is_active = 1 AND is_hidden = 0
`

type GetLibraryStatsRow struct {
	TotalCount int64       `json:"totalCount"`
	TotalSize  int64       `json:"totalSize"`
	LastScan   interface{} `json:"lastScan"`
}

func (q *Queries) GetLibraryStats(ctx context.Context) (GetLibraryStatsRow, error) {
	row := q.queryRow(ctx, q.getLibraryStatsStmt, getLibraryStats)
	var i GetLibraryStatsRow
	err := row.Scan(&i.TotalCount, &i.TotalSize, &i.LastScan)
	return i, err
}

const getSidebarStats = `-- name: GetSidebarStats :one
SELECT
    (SELECT COUNT(*) FROM assets a
     JOIN scan_folders f ON a.scan_folder_id = f.id
     WHERE a.is_deleted = 0 AND f.is_deleted = 0 AND f.is_active = 1 AND a.is_hidden = 0) as all_count,

    (SELECT COUNT(*) FROM assets a
     JOIN scan_folders f ON a.scan_folder_id = f.id
     WHERE a.is_favorite = 1 AND a.is_deleted = 0 AND f.is_deleted = 0 AND f.is_active = 1 AND a.is_hidden = 0) as favorites_count,

    (SELECT COUNT(*) FROM assets WHERE is_deleted = 1 AND is_hidden = 0) as trash_count,

    (SELECT COUNT(*) FROM assets WHERE is_hidden = 1 AND is_deleted = 0) as hidden_count,

    (SELECT COUNT(DISTINCT a.id)
     FROM assets a
     LEFT JOIN asset_tags at ON a.id = at.asset_id
     JOIN scan_folders f ON a.scan_folder_id = f.id
     WHERE at.tag_id IS NULL AND a.is_deleted = 0 AND f.is_deleted = 0 AND f.is_active = 1 AND a.is_hidden = 0) as uncategorized_count
`

type GetSidebarStatsRow struct {
	AllCount           int64 `json:"allCount"`
	FavoritesCount     int64 `json:"favoritesCount"`
	TrashCount         int64 `json:"trashCount"`
	HiddenCount        int64 `json:"hiddenCount"`
	UncategorizedCount int64 `json:"uncategorizedCount"`
}

func (q *Queries) GetSidebarStats(ctx context.Context) (GetSidebarStatsRow, error) {
	row := q.queryRow(ctx, q.getSidebarStatsStmt, getSidebarStats)
	var i GetSidebarStatsRow
	err := row.Scan(
		&i.AllCount,
		&i.FavoritesCount,
		&i.TrashCount,
		&i.HiddenCount,
		&i.UncategorizedCount,
	)
	return i, err
}

const listAssets = `-- name: ListAssets :many
SELECT a.id, a.scan_folder_id, a.group_id, a.file_name, a.file_path, a.file_type, a.file_size, a.thumbnail_path, a.rating, a.description, a.is_favorite, a.image_width, a.image_height, a.dominant_color, a.bit_depth, a.has_alpha_channel, a.date_added, a.last_scanned, a.last_modified, a.file_hash, a.is_deleted, a.deleted_at, a.is_hidden FROM assets a
JOIN scan_folders f ON a.scan_folder_id = f.id
WHERE a.is_deleted = 0
  AND f.is_deleted = 0
  AND f.is_active = 1
  AND is_hidden = 0
ORDER BY a.date_added DESC
LIMIT ? OFFSET ?
`

type ListAssetsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListAssets(ctx context.Context, arg ListAssetsParams) ([]Asset, error) {
	rows, err := q.query(ctx, q.listAssetsStmt, listAssets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.ScanFolderID,
			&i.GroupID,
			&i.FileName,
			&i.FilePath,
			&i.FileType,
			&i.FileSize,
			&i.ThumbnailPath,
			&i.Rating,
			&i.Description,
			&i.IsFavorite,
			&i.ImageWidth,
			&i.ImageHeight,
			&i.DominantColor,
			&i.BitDepth,
			&i.HasAlphaChannel,
			&i.DateAdded,
			&i.LastScanned,
			&i.LastModified,
			&i.FileHash,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.IsHidden,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssetsForCache = `-- name: ListAssetsForCache :many
SELECT id,file_path,last_modified,is_deleted,scan_folder_id FROM assets
`

type ListAssetsForCacheRow struct {
	ID           int64         `json:"id"`
	FilePath     string        `json:"filePath"`
	LastModified time.Time     `json:"lastModified"`
	IsDeleted    bool          `json:"isDeleted"`
	ScanFolderID sql.NullInt64 `json:"scanFolderId"`
}

func (q *Queries) ListAssetsForCache(ctx context.Context) ([]ListAssetsForCacheRow, error) {
	rows, err := q.query(ctx, q.listAssetsForCacheStmt, listAssetsForCache)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAssetsForCacheRow
	for rows.Next() {
		var i ListAssetsForCacheRow
		if err := rows.Scan(
			&i.ID,
			&i.FilePath,
			&i.LastModified,
			&i.IsDeleted,
			&i.ScanFolderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeletedAssets = `-- name: ListDeletedAssets :many
SELECT id, scan_folder_id, group_id, file_name, file_path, file_type, file_size, thumbnail_path, rating, description, is_favorite, image_width, image_height, dominant_color, bit_depth, has_alpha_channel, date_added, last_scanned, last_modified, file_hash, is_deleted, deleted_at, is_hidden FROM assets
WHERE is_deleted = 1 AND is_hidden = 0
ORDER BY deleted_at DESC
LIMIT ? OFFSET ?
`

type ListDeletedAssetsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListDeletedAssets(ctx context.Context, arg ListDeletedAssetsParams) ([]Asset, error) {
	rows, err := q.query(ctx, q.listDeletedAssetsStmt, listDeletedAssets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.ScanFolderID,
			&i.GroupID,
			&i.FileName,
			&i.FilePath,
			&i.FileType,
			&i.FileSize,
			&i.ThumbnailPath,
			&i.Rating,
			&i.Description,
			&i.IsFavorite,
			&i.ImageWidth,
			&i.ImageHeight,
			&i.DominantColor,
			&i.BitDepth,
			&i.HasAlphaChannel,
			&i.DateAdded,
			&i.LastScanned,
			&i.LastModified,
			&i.FileHash,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.IsHidden,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFavoriteAssets = `-- name: ListFavoriteAssets :many
SELECT a.id, a.scan_folder_id, a.group_id, a.file_name, a.file_path, a.file_type, a.file_size, a.thumbnail_path, a.rating, a.description, a.is_favorite, a.image_width, a.image_height, a.dominant_color, a.bit_depth, a.has_alpha_channel, a.date_added, a.last_scanned, a.last_modified, a.file_hash, a.is_deleted, a.deleted_at, a.is_hidden FROM assets a
JOIN scan_folders f ON a.scan_folder_id = f.id
WHERE a.is_favorite = 1
  AND a.is_deleted = 0
  AND f.is_deleted = 0
  AND f.is_active = 1
  AND is_hidden = 0
ORDER BY a.date_added DESC
LIMIT ? OFFSET ?
`

type ListFavoriteAssetsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListFavoriteAssets(ctx context.Context, arg ListFavoriteAssetsParams) ([]Asset, error) {
	rows, err := q.query(ctx, q.listFavoriteAssetsStmt, listFavoriteAssets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.ScanFolderID,
			&i.GroupID,
			&i.FileName,
			&i.FilePath,
			&i.FileType,
			&i.FileSize,
			&i.ThumbnailPath,
			&i.Rating,
			&i.Description,
			&i.IsFavorite,
			&i.ImageWidth,
			&i.ImageHeight,
			&i.DominantColor,
			&i.BitDepth,
			&i.HasAlphaChannel,
			&i.DateAdded,
			&i.LastScanned,
			&i.LastModified,
			&i.FileHash,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.IsHidden,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHiddenAssets = `-- name: ListHiddenAssets :many
SELECT id, scan_folder_id, group_id, file_name, file_path, file_type, file_size, thumbnail_path, rating, description, is_favorite, image_width, image_height, dominant_color, bit_depth, has_alpha_channel, date_added, last_scanned, last_modified, file_hash, is_deleted, deleted_at, is_hidden FROM assets
WHERE is_hidden = 1 AND is_deleted = 0
ORDER BY deleted_at DESC
LIMIT ? OFFSET ?
`

type ListHiddenAssetsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListHiddenAssets(ctx context.Context, arg ListHiddenAssetsParams) ([]Asset, error) {
	rows, err := q.query(ctx, q.listHiddenAssetsStmt, listHiddenAssets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.ScanFolderID,
			&i.GroupID,
			&i.FileName,
			&i.FilePath,
			&i.FileType,
			&i.FileSize,
			&i.ThumbnailPath,
			&i.Rating,
			&i.Description,
			&i.IsFavorite,
			&i.ImageWidth,
			&i.ImageHeight,
			&i.DominantColor,
			&i.BitDepth,
			&i.HasAlphaChannel,
			&i.DateAdded,
			&i.LastScanned,
			&i.LastModified,
			&i.FileHash,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.IsHidden,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUntaggedAssets = `-- name: ListUntaggedAssets :many
SELECT a.id, a.scan_folder_id, a.group_id, a.file_name, a.file_path, a.file_type, a.file_size, a.thumbnail_path, a.rating, a.description, a.is_favorite, a.image_width, a.image_height, a.dominant_color, a.bit_depth, a.has_alpha_channel, a.date_added, a.last_scanned, a.last_modified, a.file_hash, a.is_deleted, a.deleted_at, a.is_hidden FROM assets a
LEFT JOIN asset_tags at ON a.id = at.asset_id
JOIN scan_folders f ON a.scan_folder_id = f.id
WHERE at.tag_id IS NULL
  AND a.is_deleted = 0
  AND f.is_deleted = 0
  AND f.is_active = 1
  AND is_hidden = 0
GROUP BY a.id
LIMIT ? OFFSET ?
`

type ListUntaggedAssetsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListUntaggedAssets(ctx context.Context, arg ListUntaggedAssetsParams) ([]Asset, error) {
	rows, err := q.query(ctx, q.listUntaggedAssetsStmt, listUntaggedAssets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.ScanFolderID,
			&i.GroupID,
			&i.FileName,
			&i.FilePath,
			&i.FileType,
			&i.FileSize,
			&i.ThumbnailPath,
			&i.Rating,
			&i.Description,
			&i.IsFavorite,
			&i.ImageWidth,
			&i.ImageHeight,
			&i.DominantColor,
			&i.BitDepth,
			&i.HasAlphaChannel,
			&i.DateAdded,
			&i.LastScanned,
			&i.LastModified,
			&i.FileHash,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.IsHidden,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const moveAssetsToFolder = `-- name: MoveAssetsToFolder :exec
UPDATE assets SET scan_folder_id = ? WHERE scan_folder_id = ?
`

type MoveAssetsToFolderParams struct {
	ScanFolderID   sql.NullInt64 `json:"scanFolderId"`
	ScanFolderID_2 sql.NullInt64 `json:"scanFolderId2"`
}

func (q *Queries) MoveAssetsToFolder(ctx context.Context, arg MoveAssetsToFolderParams) error {
	_, err := q.exec(ctx, q.moveAssetsToFolderStmt, moveAssetsToFolder, arg.ScanFolderID, arg.ScanFolderID_2)
	return err
}

const refreshAssetTechnicalMetadata = `-- name: RefreshAssetTechnicalMetadata :exec
UPDATE assets
SET
    file_size = ?,
    last_modified = ?,
    last_scanned = ?,
    thumbnail_path = ?,
    image_width = ?,
    image_height = ?,
    dominant_color = ?,
    bit_depth = ?,
    has_alpha_channel = ?
WHERE id = ?
`

type RefreshAssetTechnicalMetadataParams struct {
	FileSize        int64          `json:"fileSize"`
	LastModified    time.Time      `json:"lastModified"`
	LastScanned     time.Time      `json:"lastScanned"`
	ThumbnailPath   string         `json:"thumbnailPath"`
	ImageWidth      sql.NullInt64  `json:"imageWidth"`
	ImageHeight     sql.NullInt64  `json:"imageHeight"`
	DominantColor   sql.NullString `json:"dominantColor"`
	BitDepth        sql.NullInt64  `json:"bitDepth"`
	HasAlphaChannel sql.NullBool   `json:"hasAlphaChannel"`
	ID              int64          `json:"id"`
}

func (q *Queries) RefreshAssetTechnicalMetadata(ctx context.Context, arg RefreshAssetTechnicalMetadataParams) error {
	_, err := q.exec(ctx, q.refreshAssetTechnicalMetadataStmt, refreshAssetTechnicalMetadata,
		arg.FileSize,
		arg.LastModified,
		arg.LastScanned,
		arg.ThumbnailPath,
		arg.ImageWidth,
		arg.ImageHeight,
		arg.DominantColor,
		arg.BitDepth,
		arg.HasAlphaChannel,
		arg.ID,
	)
	return err
}

const renameAsset = `-- name: RenameAsset :one
UPDATE assets
SET file_name = ?, file_path = ?
WHERE id = ?
RETURNING id, scan_folder_id, group_id, file_name, file_path, file_type, file_size, thumbnail_path, rating, description, is_favorite, image_width, image_height, dominant_color, bit_depth, has_alpha_channel, date_added, last_scanned, last_modified, file_hash, is_deleted, deleted_at, is_hidden
`

type RenameAssetParams struct {
	FileName string `json:"fileName"`
	FilePath string `json:"filePath"`
	ID       int64  `json:"id"`
}

func (q *Queries) RenameAsset(ctx context.Context, arg RenameAssetParams) (Asset, error) {
	row := q.queryRow(ctx, q.renameAssetStmt, renameAsset, arg.FileName, arg.FilePath, arg.ID)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.ScanFolderID,
		&i.GroupID,
		&i.FileName,
		&i.FilePath,
		&i.FileType,
		&i.FileSize,
		&i.ThumbnailPath,
		&i.Rating,
		&i.Description,
		&i.IsFavorite,
		&i.ImageWidth,
		&i.ImageHeight,
		&i.DominantColor,
		&i.BitDepth,
		&i.HasAlphaChannel,
		&i.DateAdded,
		&i.LastScanned,
		&i.LastModified,
		&i.FileHash,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.IsHidden,
	)
	return i, err
}

const restoreAsset = `-- name: RestoreAsset :exec
UPDATE assets
SET is_deleted = 0, deleted_at = NULL
WHERE id = ?
`

func (q *Queries) RestoreAsset(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.restoreAssetStmt, restoreAsset, id)
	return err
}

const restoreAssets = `-- name: RestoreAssets :exec
UPDATE assets
SET is_deleted = 0, deleted_at = NULL
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) RestoreAssets(ctx context.Context, ids []int64) error {
	query := restoreAssets
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.exec(ctx, nil, query, queryParams...)
	return err
}

const setAssetHidden = `-- name: SetAssetHidden :exec
UPDATE assets SET is_hidden = ? WHERE id = ?
`

type SetAssetHiddenParams struct {
	IsHidden bool  `json:"isHidden"`
	ID       int64 `json:"id"`
}

func (q *Queries) SetAssetHidden(ctx context.Context, arg SetAssetHiddenParams) error {
	_, err := q.exec(ctx, q.setAssetHiddenStmt, setAssetHidden, arg.IsHidden, arg.ID)
	return err
}

const setAssetRating = `-- name: SetAssetRating :exec
UPDATE assets SET rating = ? WHERE id = ?
`

type SetAssetRatingParams struct {
	Rating int64 `json:"rating"`
	ID     int64 `json:"id"`
}

func (q *Queries) SetAssetRating(ctx context.Context, arg SetAssetRatingParams) error {
	_, err := q.exec(ctx, q.setAssetRatingStmt, setAssetRating, arg.Rating, arg.ID)
	return err
}

const setAssetsHiddenByFolderId = `-- name: SetAssetsHiddenByFolderId :exec
UPDATE assets
SET is_hidden = ?
WHERE scan_folder_id = ?
`

type SetAssetsHiddenByFolderIdParams struct {
	IsHidden     bool          `json:"isHidden"`
	ScanFolderID sql.NullInt64 `json:"scanFolderId"`
}

func (q *Queries) SetAssetsHiddenByFolderId(ctx context.Context, arg SetAssetsHiddenByFolderIdParams) error {
	_, err := q.exec(ctx, q.setAssetsHiddenByFolderIdStmt, setAssetsHiddenByFolderId, arg.IsHidden, arg.ScanFolderID)
	return err
}

const softDeleteAsset = `-- name: SoftDeleteAsset :exec
UPDATE assets
SET is_deleted = 1, is_hidden = 0, deleted_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) SoftDeleteAsset(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.softDeleteAssetStmt, softDeleteAsset, id)
	return err
}

const softDeleteAssets = `-- name: SoftDeleteAssets :exec
UPDATE assets
SET is_deleted = 1, is_hidden = 0, deleted_at = CURRENT_TIMESTAMP
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) SoftDeleteAssets(ctx context.Context, ids []int64) error {
	query := softDeleteAssets
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.exec(ctx, nil, query, queryParams...)
	return err
}

const toggleAssetFavorite = `-- name: ToggleAssetFavorite :exec
UPDATE assets SET is_favorite = NOT is_favorite WHERE id = ?
`

func (q *Queries) ToggleAssetFavorite(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.toggleAssetFavoriteStmt, toggleAssetFavorite, id)
	return err
}

const updateAssetFromScan = `-- name: UpdateAssetFromScan :one
UPDATE assets
SET
    -- Identyfikacja i Status (Move / Rename / Restore)
    file_path = COALESCE(?1, file_path),
    scan_folder_id = COALESCE(?2, scan_folder_id),
    is_deleted = COALESCE(?3, is_deleted),

    -- Metadane Techniczne (Refresh Content)
    file_size = COALESCE(?4, file_size),
    file_hash = COALESCE(?5, file_hash),
    last_modified = COALESCE(?6, last_modified),
    last_scanned = COALESCE(?7, last_scanned),

    -- Metadane Obrazu (Thumbnail Generator)
    thumbnail_path = COALESCE(?8, thumbnail_path),
    image_width = COALESCE(?9, image_width),
    image_height = COALESCE(?10, image_height),
    dominant_color = COALESCE(?11, dominant_color),
    bit_depth = COALESCE(?12, bit_depth),
    has_alpha_channel = COALESCE(?13, has_alpha_channel)
WHERE id = ?14
RETURNING id, scan_folder_id, group_id, file_name, file_path, file_type, file_size, thumbnail_path, rating, description, is_favorite, image_width, image_height, dominant_color, bit_depth, has_alpha_channel, date_added, last_scanned, last_modified, file_hash, is_deleted, deleted_at, is_hidden
`

type UpdateAssetFromScanParams struct {
	FilePath        sql.NullString `json:"filePath"`
	ScanFolderID    sql.NullInt64  `json:"scanFolderId"`
	IsDeleted       sql.NullBool   `json:"isDeleted"`
	FileSize        sql.NullInt64  `json:"fileSize"`
	FileHash        sql.NullString `json:"fileHash"`
	LastModified    sql.NullTime   `json:"lastModified"`
	LastScanned     sql.NullTime   `json:"lastScanned"`
	ThumbnailPath   sql.NullString `json:"thumbnailPath"`
	ImageWidth      sql.NullInt64  `json:"imageWidth"`
	ImageHeight     sql.NullInt64  `json:"imageHeight"`
	DominantColor   sql.NullString `json:"dominantColor"`
	BitDepth        sql.NullInt64  `json:"bitDepth"`
	HasAlphaChannel sql.NullBool   `json:"hasAlphaChannel"`
	ID              int64          `json:"id"`
}

func (q *Queries) UpdateAssetFromScan(ctx context.Context, arg UpdateAssetFromScanParams) (Asset, error) {
	row := q.queryRow(ctx, q.updateAssetFromScanStmt, updateAssetFromScan,
		arg.FilePath,
		arg.ScanFolderID,
		arg.IsDeleted,
		arg.FileSize,
		arg.FileHash,
		arg.LastModified,
		arg.LastScanned,
		arg.ThumbnailPath,
		arg.ImageWidth,
		arg.ImageHeight,
		arg.DominantColor,
		arg.BitDepth,
		arg.HasAlphaChannel,
		arg.ID,
	)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.ScanFolderID,
		&i.GroupID,
		&i.FileName,
		&i.FilePath,
		&i.FileType,
		&i.FileSize,
		&i.ThumbnailPath,
		&i.Rating,
		&i.Description,
		&i.IsFavorite,
		&i.ImageWidth,
		&i.ImageHeight,
		&i.DominantColor,
		&i.BitDepth,
		&i.HasAlphaChannel,
		&i.DateAdded,
		&i.LastScanned,
		&i.LastModified,
		&i.FileHash,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.IsHidden,
	)
	return i, err
}

const updateAssetLocation = `-- name: UpdateAssetLocation :exec
UPDATE assets
SET file_path = ?, scan_folder_id = ?, is_deleted = false, last_scanned = ?
WHERE id = ?
`

type UpdateAssetLocationParams struct {
	FilePath     string        `json:"filePath"`
	ScanFolderID sql.NullInt64 `json:"scanFolderId"`
	LastScanned  time.Time     `json:"lastScanned"`
	ID           int64         `json:"id"`
}

func (q *Queries) UpdateAssetLocation(ctx context.Context, arg UpdateAssetLocationParams) error {
	_, err := q.exec(ctx, q.updateAssetLocationStmt, updateAssetLocation,
		arg.FilePath,
		arg.ScanFolderID,
		arg.LastScanned,
		arg.ID,
	)
	return err
}

const updateAssetMetadata = `-- name: UpdateAssetMetadata :one
UPDATE assets
SET
    description = COALESCE(?1, description),
    rating = COALESCE(?2, rating),
    is_favorite = COALESCE(?3, is_favorite),
    thumbnail_path = COALESCE(?4, thumbnail_path)
WHERE id = ?5
RETURNING id, scan_folder_id, group_id, file_name, file_path, file_type, file_size, thumbnail_path, rating, description, is_favorite, image_width, image_height, dominant_color, bit_depth, has_alpha_channel, date_added, last_scanned, last_modified, file_hash, is_deleted, deleted_at, is_hidden
`

type UpdateAssetMetadataParams struct {
	Description   sql.NullString `json:"description"`
	Rating        sql.NullInt64  `json:"rating"`
	IsFavorite    sql.NullBool   `json:"isFavorite"`
	ThumbnailPath sql.NullString `json:"thumbnailPath"`
	ID            int64          `json:"id"`
}

func (q *Queries) UpdateAssetMetadata(ctx context.Context, arg UpdateAssetMetadataParams) (Asset, error) {
	row := q.queryRow(ctx, q.updateAssetMetadataStmt, updateAssetMetadata,
		arg.Description,
		arg.Rating,
		arg.IsFavorite,
		arg.ThumbnailPath,
		arg.ID,
	)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.ScanFolderID,
		&i.GroupID,
		&i.FileName,
		&i.FilePath,
		&i.FileType,
		&i.FileSize,
		&i.ThumbnailPath,
		&i.Rating,
		&i.Description,
		&i.IsFavorite,
		&i.ImageWidth,
		&i.ImageHeight,
		&i.DominantColor,
		&i.BitDepth,
		&i.HasAlphaChannel,
		&i.DateAdded,
		&i.LastScanned,
		&i.LastModified,
		&i.FileHash,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.IsHidden,
	)
	return i, err
}

const updateAssetScanStatus = `-- name: UpdateAssetScanStatus :exec
UPDATE assets
SET last_scanned = ?, file_size = ?, last_modified = ?
WHERE id = ?
`

type UpdateAssetScanStatusParams struct {
	LastScanned  time.Time `json:"lastScanned"`
	FileSize     int64     `json:"fileSize"`
	LastModified time.Time `json:"lastModified"`
	ID           int64     `json:"id"`
}

func (q *Queries) UpdateAssetScanStatus(ctx context.Context, arg UpdateAssetScanStatusParams) error {
	_, err := q.exec(ctx, q.updateAssetScanStatusStmt, updateAssetScanStatus,
		arg.LastScanned,
		arg.FileSize,
		arg.LastModified,
		arg.ID,
	)
	return err
}

const updateAssetType = `-- name: UpdateAssetType :exec
UPDATE assets
SET file_type = ?
WHERE id = ?
`

type UpdateAssetTypeParams struct {
	FileType string `json:"fileType"`
	ID       int64  `json:"id"`
}

func (q *Queries) UpdateAssetType(ctx context.Context, arg UpdateAssetTypeParams) error {
	_, err := q.exec(ctx, q.updateAssetTypeStmt, updateAssetType, arg.FileType, arg.ID)
	return err
}
